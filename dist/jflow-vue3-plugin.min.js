(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue'), require('@joskii/jflow-core')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue', '@joskii/jflow-core'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["jflow-vue3-plugin"] = {}, global.vue, global["@joskii/jflow-core"]));
})(this, (function (exports, vue, JFlowInstance$1) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
      Object.keys(e).forEach(function (k) {
        if (k !== 'default') {
          var d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: function () { return e[k]; }
          });
        }
      });
    }
    n["default"] = e;
    return Object.freeze(n);
  }

  var JFlowInstance__default = /*#__PURE__*/_interopDefaultLegacy(JFlowInstance$1);
  var JFlowInstance__namespace = /*#__PURE__*/_interopNamespace(JFlowInstance$1);

  function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
      var _s,
        _e,
        _x,
        _r,
        _arr = [],
        _n = !0,
        _d = !1;
      try {
        if (_x = (_i = _i.call(arr)).next, 0 === i) {
          if (Object(_i) !== _i) return;
          _n = !1;
        } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);
      } catch (err) {
        _d = !0, _e = err;
      } finally {
        try {
          if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;
        } finally {
          if (_d) throw _e;
        }
      }
      return _arr;
    }
  }
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;
      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);
        _cache.set(Class, Wrapper);
      }
      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };
    return _wrapNativeSuper(Class);
  }
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }
  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf(Derived),
        result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object") return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }

  function useStack (_jflowInstance) {
    // const stack = ref([]);
    function addToStack(instance, source) {
      _jflowInstance.addToStack(instance);
      if (source) {
        source = vue.toRaw(source);
        instance._jflow.setRenderNodeBySource(source, instance);
      }
    }
    function removeFromStack(instance) {
      _jflowInstance.removeFromStack(instance);
    }
    vue.provide('addToStack', addToStack);
    vue.provide('removeFromStack', removeFromStack);
  }

  function useLinkStack (_jflowInstance) {
    // const stack = ref([]);
    function addToLinkStack(link, sourceFrom, sourceTo) {
      _jflowInstance.addToLinkStack(link);
      if (sourceFrom && sourceTo) {
        _jflowInstance.addLinkNodeBySource(sourceFrom, sourceTo, link);
      }
    }
    function removeFromLinkStack(link, sourceFrom, sourceTo) {
      _jflowInstance.removeFromLinkStack(link);
      if (sourceFrom && sourceTo) {
        _jflowInstance.removeLinkNodeBySource(sourceFrom, sourceTo, link);
      }
    }
    vue.provide('addToLinkStack', addToLinkStack);
    vue.provide('removeFromLinkStack', removeFromLinkStack);
  }

  function lowerFirstLetter(string) {
    return string.charAt(0).toLowerCase() + string.slice(1);
  }
  function bindEvent(_jflowInstance, attrs) {
    Object.keys(attrs).map(function (key) {
      if (/^on[A-Z]/.test(key)) {
        // TODO 整理固定的 Event
        var func = attrs[key];
        if (Array.isArray(func)) {
          func = func.filter(function (f) {
            return typeof f === 'function';
          });
          var reg = /^on(.*)/.exec(key);
          if (reg[1]) {
            var eventName = lowerFirstLetter(reg[1]);
            func.forEach(function (f) {
              _jflowInstance.addEventListener(eventName, f);
            });
          }
        } else if (func && typeof func === 'function') {
          var _reg = /^on(.*)/.exec(key);
          if (_reg[1]) {
            _jflowInstance.addEventListener(lowerFirstLetter(_reg[1]), func);
          }
        }
      }
    });
  }

  var JFlowComponent = {
    props: {
      configs: {
        type: Object,
        "default": function _default() {
          return {};
        }
      },
      loading: Boolean,
      genVueComponentKey: {
        type: Function
      }
    },
    inheritAttrs: false,
    setup: function setup(props, _ref) {
      var _this = this;
      var slots = _ref.slots,
        attrs = _ref.attrs,
        emit = _ref.emit,
        expose = _ref.expose;
      var genVueComponentKey = props.genVueComponentKey;
      var genLinkVueComponentKey = function genLinkVueComponentKey(meta) {
        var k1 = genVueComponentKey(meta.from.source);
        var k2 = genVueComponentKey(meta.to.source);
        var k3 = meta.part;
        return "".concat(k1, "-").concat(k2, "-").concat(k3);
      };
      var className = attrs["class"];
      var style = attrs.style;
      var divEl = vue.ref();
      var stopLoading = false;
      var renderNodes = vue.ref([]);
      var renderLinks = vue.ref([]);
      var _jflowInstance = new JFlowInstance__default["default"](vue.toRaw(props.configs));
      useStack(_jflowInstance);
      useLinkStack(_jflowInstance);
      var genNodeLinkMeta = function genNodeLinkMeta() {
        var nodes = _jflowInstance._layout.flowStack.map(function (meta) {
          meta.type;
            var layoutNode = meta.layoutNode,
            source = meta.source;
          var map = _jflowInstance.source_Layout_Render_NodeMap;
          var obj;
          var s = vue.toRaw(source);
          var ly = vue.toRaw(layoutNode);
          if (map.has(s)) {
            obj = map.get(s);
          } else {
            obj = map.set(s);
          }
          obj.layoutNode = ly;
          return meta;
        });
        var links = _jflowInstance._layout.flowLinkStack.slice();
        return [nodes, links];
      };
      var loadingNodes = function loadingNodes(nodes, links) {
        emit('update:loading', true);
        var i = 0;
        var tl = function tl() {
          if (stopLoading) {
            return;
          }
          var end = i + 100;
          var linkPart = links.slice(i, end);
          if (linkPart.length) {
            // this.renderLinks.splice(this.renderLinks.length,  0, ...linkPart);
            renderLinks.value = renderLinks.value.concat(linkPart); // faster
            i = end;
            requestAnimationFrame(tl);
          } else {
            requestAnimationFrame(mountJFlow.bind(_this));
          }
        };
        var tn = function tn() {
          if (stopLoading) {
            return;
          }
          var end = i + 100;
          var part = nodes.slice(i, end);
          if (part.length) {
            // this.renderNodes.splice(this.renderNodes.length,  0, ...part);
            renderNodes.value = renderNodes.value.concat(part);
            i = end;
            requestAnimationFrame(tn);
          } else {
            i = 0;
            requestAnimationFrame(tl);
          }
        };
        requestAnimationFrame(tn);
      };
      vue.onBeforeMount(function () {
        loadingNodes.apply(void 0, _toConsumableArray(genNodeLinkMeta()));
      });
      var mountJFlow = function mountJFlow() {
        if (stopLoading) {
          return;
        }
        _jflowInstance.$mount(divEl.value);
        bindEvent(_jflowInstance, attrs);
        emit('update:loading', false);
      };
      vue.onUnmounted(function () {
        if (_jflowInstance.destroy) {
          _jflowInstance.destroy();
        }
        stopLoading = true;
      });
      var syncNodeLink = function syncNodeLink(nodes, links) {
        renderNodes.value = nodes.slice();
        renderLinks.value = links.slice();
      };

      // syncNodeLink(...genNodeLinkMeta());
      // nextTick(() => {
      //     mountJFlow();
      // })

      var reflow = function reflow(preCallback, afterCallback) {
        syncNodeLink.apply(void 0, _toConsumableArray(genNodeLinkMeta()));
        vue.nextTick(function () {
          if (preCallback) {
            preCallback();
          }
          _jflowInstance.recalculate();
          _jflowInstance.scheduleRender(function () {
            if (afterCallback) {
              afterCallback();
            }
          });
        });
      };
      var syncLayout = function syncLayout() {
        syncNodeLink.apply(void 0, _toConsumableArray(genNodeLinkMeta()));
      };
      var getInstance = function getInstance() {
        return _jflowInstance;
      };
      var renderJFlow = function () {
        var __renderInSchedule__ = false;
        return function () {
          if (__renderInSchedule__) {
            return;
          }
          __renderInSchedule__ = true;
          vue.nextTick(function () {
            _jflowInstance._render();
            __renderInSchedule__ = false;
          });
        };
      }();
      vue.provide('getJFlow', getInstance);
      vue.provide('renderJFlow', renderJFlow);
      expose({
        reflow: reflow,
        renderJFlow: renderJFlow,
        getInstance: getInstance,
        syncLayout: syncLayout
      });
      return function () {
        return vue.h('div', {
          "class": className,
          style: style,
          ref: divEl
        }, !renderNodes.value.length ? null : vue.h('div', [].concat(_toConsumableArray(renderNodes.value.map(function (node) {
          if (!node) {
            return null;
          }
          var type = node.type,
            source = node.source,
            layoutNode = node.layoutNode;
          // layoutNode = toRaw(layoutNode);
          if (!slots[type]) {
            if (slots['jflowcommon']) {
              type = 'jflowcommon';
            } else {
              return null;
            }
          }
          var _slots$type = slots[type]({
              source: source,
              layoutNode: layoutNode
            }),
            _slots$type2 = _slicedToArray(_slots$type, 1),
            vnode = _slots$type2[0];
          vnode.key = genVueComponentKey(source);
          return vnode;
        }).filter(function (n) {
          return !!n;
        })), _toConsumableArray(renderLinks.value.map(function (meta) {
          var type = meta.type || 'plainlink';
          if (!slots[type]) {
            return null;
          }
          var _slots$type3 = slots[type]({
              configs: meta
            }),
            _slots$type4 = _slicedToArray(_slots$type3, 1),
            vnode = _slots$type4[0];
          vnode.key = genLinkVueComponentKey(meta);
          return vnode;
        })))));
      };
    }
  };

  function diff(a, b) {
    return Object.keys(b).some(function (k) {
      return b[k] !== a[k];
    }) || Object.keys(a).some(function (k) {
      return b[k] !== a[k];
    });
  }
  function JFlowInstance (nameNode) {
    var builder = typeof nameNode === 'string' ? JFlowInstance__namespace[nameNode] : nameNode;
    return {
      inheritAttrs: false,
      props: {
        configs: {
          type: Object,
          "default": function _default() {
            return {};
          }
        },
        visible: {
          type: Boolean,
          "default": true
        },
        source: {
          type: Object
        }
      },
      setup: function setup(props, _ref) {
        var attrs = _ref.attrs,
          expose = _ref.expose;
        var addToBelongStack = vue.inject('addToStack');
        var removeFromBelongStack = vue.inject('removeFromStack');
        var renderJFlow = vue.inject('renderJFlow');
        var _jflowInstance = new builder(vue.toRaw(props.configs));
        bindEvent(_jflowInstance, attrs);
        addToBelongStack(_jflowInstance, vue.toRaw(props.source));
        var stop0 = vue.watch(function () {
          return props.configs;
        }, function (val, oldVal) {
          if (!diff(val, oldVal)) {
            return;
          }
          _jflowInstance.setConfig(val);
          renderJFlow();
        });
        var setVisible = function setVisible(val) {
          _jflowInstance.visible = val;
          renderJFlow();
        };
        var stop1 = vue.watch(function () {
          return props.visible;
        }, setVisible);
        var stop2 = vue.watch(function () {
          return props.source;
        }, function (val) {
          _jflowInstance._jflow.setRenderNodeBySource(vue.toRaw(val), _jflowInstance);
        });
        setVisible(props.visible);
        vue.onUnmounted(function () {
          stop0();
          stop1();
          stop2();
          _jflowInstance.destroy();
          removeFromBelongStack(_jflowInstance);
        });
        expose({
          _jflowInstance: _jflowInstance
        });
        return function () {
          return null;
        };
      }
    };
  }

  function JFlowLink (nameNode) {
    var builder = typeof nameNode === 'string' ? JFlowInstance__namespace[nameNode] : nameNode;
    return {
      inheritAttrs: false,
      props: {
        configs: {
          type: Object,
          "default": function _default() {
            return {};
          }
        },
        from: Object,
        to: Object
      },
      setup: function setup(props, _ref) {
        var attrs = _ref.attrs,
          expose = _ref.expose;
        var addToLinkStack = vue.inject('addToLinkStack');
        var removeFromLinkStack = vue.inject('removeFromLinkStack');
        var getJFlow = vue.inject('getJFlow');
        var renderJFlow = vue.inject('renderJFlow');
        var jflow = getJFlow();
        var exposeObj = {
          _jflowInstance: null
        };
        var createInstance = function createInstance(fromInstance, toInstance) {
          if (fromInstance && toInstance) {
            var _jflowInstance = new builder(_objectSpread2(_objectSpread2({}, props.configs), {}, {
              from: fromInstance,
              to: toInstance
            }));
            bindEvent(_jflowInstance, attrs);
            addToLinkStack(_jflowInstance, vue.toRaw(props.from), vue.toRaw(props.to));
            exposeObj._jflowInstance = _jflowInstance;
          }
        };
        var refresh = function refresh() {
          var fromInstance = jflow.getRenderNodeBySource(vue.toRaw(props.from));
          var toInstance = jflow.getRenderNodeBySource(vue.toRaw(props.to));
          if (!exposeObj._jflowInstance) {
            createInstance(fromInstance, toInstance);
          } else {
            exposeObj._jflowInstance.setConfig(_objectSpread2(_objectSpread2({}, props.configs), {}, {
              from: fromInstance,
              to: toInstance
            }));
          }
          renderJFlow();
        };
        refresh();
        var stop = vue.watchEffect(function () {
          refresh();
        }, {
          flush: 'post'
        });
        vue.onUnmounted(function () {
          stop();
          if (exposeObj._jflowInstance) {
            exposeObj._jflowInstance.destroy();
            removeFromLinkStack(exposeObj._jflowInstance, vue.toRaw(props.from), vue.toRaw(props.to));
          }
        });
        expose(exposeObj);
        return function () {
          return null;
        };
      }
    };
  }

  function JFlowGroup (nameNode) {
    var builder = typeof nameNode === 'string' ? JFlowInstance__namespace[nameNode] : nameNode;
    return {
      inheritAttrs: false,
      props: {
        configs: {
          type: Object,
          "default": function _default() {
            return {};
          }
        },
        visible: {
          type: Boolean,
          "default": true
        },
        source: {
          type: Object
        }
      },
      setup: function setup(props, _ref) {
        var slots = _ref.slots,
          attrs = _ref.attrs,
          expose = _ref.expose;
        var addToBelongStack = vue.inject('addToStack');
        var removeFromBelongStack = vue.inject('removeFromStack');
        var renderJFlow = vue.inject('renderJFlow');
        var _jflowInstance = new builder(vue.toRaw(props.configs));
        useStack(_jflowInstance);
        bindEvent(_jflowInstance, attrs);
        addToBelongStack(_jflowInstance, vue.toRaw(props.source));
        var setVisible = function setVisible(val) {
          _jflowInstance.visible = val;
          renderJFlow();
        };
        var stop0 = vue.watch(function () {
          return props.configs;
        }, function (val, oldVal) {
          if (JSON.stringify(val) === JSON.stringify(oldVal)) {
            return;
          }
          _jflowInstance.setConfig(val);
          renderJFlow();
        });
        var stop1 = vue.watch(function () {
          return props.visible;
        }, setVisible);
        var stop2 = vue.watch(function () {
          return props.source;
        }, function (val) {
          _jflowInstance._jflow.setRenderNodeBySource(vue.toRaw(val), _jflowInstance);
        });
        setVisible(props.visible);
        vue.onMounted(function () {
          _jflowInstance.recalculate();
        });
        vue.onUpdated(function () {
          _jflowInstance.recalculateUp();
        });
        vue.onUnmounted(function () {
          stop0();
          stop1();
          stop2();
          _jflowInstance.destroy();
          removeFromBelongStack(_jflowInstance);
        });
        expose({
          _jflowInstance: _jflowInstance
        });
        return function () {
          return vue.h('jflow-group', slots["default"]());
        };
      }
    };
  }

  var JFlowTextGroup = {
    props: {
      configs: {
        type: Object,
        "default": function _default() {
          return {};
        }
      },
      visible: {
        type: Boolean,
        "default": true
      },
      source: {
        type: Object
      },
      genVueComponentKey: {
        type: Function
      }
    },
    inheritAttrs: false,
    setup: function setup(props, _ref) {
      var slots = _ref.slots,
        attrs = _ref.attrs;
        _ref.emit;
        var expose = _ref.expose;
      var genVueComponentKey = props.genVueComponentKey;
      var addToBelongStack = vue.inject('addToStack');
      var removeFromBelongStack = vue.inject('removeFromStack');
      var renderJFlow = vue.inject('renderJFlow');
      var renderNodes = vue.ref([]);
      var _jflowInstance = new JFlowInstance$1.TextGroup(vue.toRaw(props.configs));
      useStack(_jflowInstance);
      bindEvent(_jflowInstance, attrs);
      addToBelongStack(_jflowInstance, vue.toRaw(props.source));
      var setVisible = function setVisible(val) {
        _jflowInstance.visible = val;
        renderJFlow();
      };
      var stop0 = vue.watch(function () {
        return props.configs;
      }, function (val, oldVal) {
        if (JSON.stringify(val) === JSON.stringify(oldVal)) {
          return;
        }
        _jflowInstance.setConfig(val);
        renderJFlow();
      });
      var stop1 = vue.watch(function () {
        return props.visible;
      }, setVisible);
      var stop2 = vue.watch(function () {
        return props.source;
      }, function (val) {
        _jflowInstance._jflow.setRenderNodeBySource(vue.toRaw(val), _jflowInstance);
      });
      setVisible(props.visible);
      var genTextElementMeta = function genTextElementMeta() {
        renderNodes.value = _jflowInstance._flattenTxtElem.filter(function (elem) {
          return elem.type !== 'text';
        });
      };
      genTextElementMeta();
      var reflow = function reflow() {
        _jflowInstance.refreshTextElements();
        genTextElementMeta();
        vue.nextTick(function () {
          _jflowInstance.refresh();
        });
      };
      vue.onMounted(function () {
        _jflowInstance.recalculate();
      });
      vue.onUpdated(function () {
        _jflowInstance.recalculateUp();
      });
      vue.onUnmounted(function () {
        stop0();
        stop1();
        stop2();
        _jflowInstance.destroy();
        removeFromBelongStack(_jflowInstance);
      });
      expose({
        _jflowInstance: _jflowInstance,
        reflow: reflow
      });
      return function () {
        if (renderNodes.value.length === 0) {
          return vue.h('jflow-group');
        }
        return vue.h('div', renderNodes.value.map(function (textElement) {
          var type = textElement.type,
            source = textElement.source;
          if (!slots[type]) {
            if (slots['jflowcommon']) {
              type = 'jflowcommon';
            } else {
              return null;
            }
          }
          var _slots$type = slots[type]({
              source: source,
              textElement: textElement
            }),
            _slots$type2 = _slicedToArray(_slots$type, 1),
            vnode = _slots$type2[0];
          vnode.key = genVueComponentKey(source);
          return vnode;
        }).filter(function (n) {
          return !!n;
        }));
      };
    }
  };

  function JFlowLinkGroup (builder) {
    return {
      inheritAttrs: false,
      props: {
        configs: {
          type: Object,
          "default": function _default() {
            return {};
          }
        },
        visible: {
          type: Boolean,
          "default": true
        },
        source: {
          type: Object
        },
        genVueComponentKey: {
          type: Function
        }
      },
      setup: function setup(props, _ref) {
        var attrs = _ref.attrs,
          slots = _ref.slots,
          expose = _ref.expose;
        var addToBelongStack = vue.inject('addToStack');
        var removeFromBelongStack = vue.inject('removeFromStack');
        var renderJFlow = vue.inject('renderJFlow');
        var _jflowInstance = new builder(props.configs);
        useStack(_jflowInstance);
        bindEvent(_jflowInstance, attrs);
        addToBelongStack(_jflowInstance, vue.toRaw(props.source));
        var renderLinks = vue.ref([]);
        var genLinks = function genLinks() {
          renderLinks.value = _jflowInstance._layout.flowLinkStack.slice();
        };
        genLinks();
        var setVisible = function setVisible(val) {
          _jflowInstance.visible = val;
          renderJFlow();
        };
        var stop0 = vue.watch(function () {
          return props.configs;
        }, function (val, oldVal) {
          if (JSON.stringify(val) === JSON.stringify(oldVal)) {
            return;
          }
          _jflowInstance.setConfig(val);
          renderJFlow();
        });
        var stop1 = vue.watch(function () {
          return props.visible;
        }, setVisible);
        var stop2 = vue.watch(function () {
          return props.source;
        }, function (val) {
          _jflowInstance._jflow.setRenderNodeBySource(vue.toRaw(val), _jflowInstance);
        });
        setVisible(props.visible);
        vue.onMounted(function () {
          _jflowInstance.recalculate();
        });
        vue.onUpdated(function () {
          _jflowInstance.recalculateUp();
        });
        vue.onUnmounted(function () {
          stop0();
          stop1();
          stop2();
          _jflowInstance.destroy();
          removeFromBelongStack(_jflowInstance);
        });
        var getLinkName = function getLinkName(link) {
          var type = link.type;
          if (!slots[type]) {
            return 'plainlink';
          }
          return type;
        };
        var genLinkVueComponentKey = function genLinkVueComponentKey(meta) {
          var k1 = props.genVueComponentKey(meta.from.source);
          var k2 = props.genVueComponentKey(meta.to.source);
          var k3 = meta.part;
          return "".concat(k1, "-").concat(k2, "-").concat(k3);
        };
        expose({
          genLinks: genLinks,
          _jflowInstance: _jflowInstance
        });
        return function () {
          return vue.h('jflow-group', [].concat(_toConsumableArray(slots["default"]()), _toConsumableArray(renderLinks.value.map(function (meta) {
            var type = getLinkName(meta);
            if (!slots[type]) {
              return null;
            }
            var vnode = slots[type]({
              configs: meta
            });
            vnode.key = genLinkVueComponentKey(meta);
            return vnode;
          }))));
        };
      }
    };
  }

  var JFLOW_NODES = ['Point', 'Rectangle', 'Capsule', 'Diamond', 'Rhombus', 'Text', 'Icon', 'ShadowDom', 'TextEditor'];
  var JFLOW_LINKS = ['Link', 'PolyLink', 'BezierLink'];
  var JFLOW_GROUPS = ['CapsuleGroup', 'CapsuleVerticalGroup', 'DiamondGroup', 'DiamondVerticalGroup', 'RhombusGroup', 'PointGroup', 'ScrollGroup'];
  var components = [{
    name: 'Jflow',
    component: JFlowComponent
  }, {
    name: 'Group',
    component: JFlowGroup('Group')
  }].concat(_toConsumableArray(JFLOW_GROUPS.map(function (name) {
    return {
      name: name,
      component: JFlowGroup(name)
    };
  })), _toConsumableArray(JFLOW_NODES.map(function (name) {
    return {
      name: name,
      component: JFlowInstance(name)
    };
  })), _toConsumableArray(JFLOW_LINKS.map(function (name) {
    return {
      name: name,
      component: JFlowLink(name)
    };
  })), [{
    name: 'TextGroup',
    component: JFlowTextGroup
  }]);
  var componentPrefix = 'j';
  customElements.define('jflow-group', /*#__PURE__*/function (_HTMLElement) {
    _inherits(_class, _HTMLElement);
    var _super = _createSuper(_class);
    function _class() {
      var _this;
      _classCallCheck(this, _class);
      _this = _super.call(this);
      _this.attachShadow({
        mode: 'open'
      });
      return _this;
    }
    return _createClass(_class);
  }( /*#__PURE__*/_wrapNativeSuper(HTMLElement)));
  /**
   * @module JFlowVuePlugin 
   */
  var JFlowVuePlugin = {
    /**
     * 安装 JFlowVuePlugin
     * @function
     * @param {Vue} Vue - Vue
     * @param {Object} options - Vue plugin 配置
     * @param {string} options.prefix - 组件前缀，默认是 j
     * @param {Object} options.custom - 自定义组件，形式为 { key: {@link:Instance} }
     */
    install: function install(Vue) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var prefixToUse = componentPrefix;
      if (options && options.prefix) {
        prefixToUse = options.prefix;
      }
      components.forEach(function (k) {
        Vue.component("".concat(prefixToUse).concat(k.name), k.component);
      });
      if (options.customInstance) {
        Object.keys(options.customInstance).forEach(function (name) {
          Vue.component("".concat(prefixToUse).concat(name), JFlowInstance(options.customInstance[name]));
        });
      }
      if (options.customGroups) {
        Object.keys(options.customGroups).forEach(function (name) {
          Vue.component("".concat(prefixToUse).concat(name), JFlowGroup(options.customGroups[name]));
        });
      }
      if (options.customLink) {
        Object.keys(options.customLink).forEach(function (name) {
          Vue.component("".concat(prefixToUse).concat(name), JFlowLink(options.customLink[name]));
        });
      }
    }
  };

  exports.JFlowLinkGroup = JFlowLinkGroup;
  exports.JFlowVuePlugin = JFlowVuePlugin;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=jflow-vue3-plugin.min.js.map
