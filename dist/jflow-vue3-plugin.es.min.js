import { provide, toRaw, ref, onBeforeMount, onUnmounted, h, nextTick, inject, watch, watchEffect, onMounted, onUpdated } from 'vue';
import * as JFlowInstance$1 from '@joskii/jflow-core';
import JFlowInstance__default, { TextGroup } from '@joskii/jflow-core';

function useStack (_jflowInstance) {
    // const stack = ref([]);
    function addToStack(instance, source) {
        _jflowInstance.addToStack(instance);
        if(source) {
            source = toRaw(source);
            instance._jflow.setRenderNodeBySource(source, instance);
        }
    }
    function removeFromStack(instance) {
        _jflowInstance.removeFromStack(instance);
    }

    provide('addToStack', addToStack);
    provide('removeFromStack', removeFromStack);
}

function useLinkStack (_jflowInstance) {
    // const stack = ref([]);
    function addToLinkStack(link, sourceFrom, sourceTo) {
        _jflowInstance.addToLinkStack(link);
        if(sourceFrom && sourceTo) {
            _jflowInstance.addLinkNodeBySource(sourceFrom, sourceTo, link);
        }
    }
    function removeFromLinkStack(link, sourceFrom, sourceTo) {
        _jflowInstance.removeFromLinkStack(link);
        if(sourceFrom && sourceTo) {
            _jflowInstance.removeLinkNodeBySource(sourceFrom, sourceTo, link);
        }
    }

    provide('addToLinkStack', addToLinkStack);
    provide('removeFromLinkStack', removeFromLinkStack);
}

function lowerFirstLetter(string) {
    return string.charAt(0).toLowerCase() + string.slice(1);
}

function bindEvent(_jflowInstance, attrs) {
    Object.keys(attrs).map(key => {
        if(/^on[A-Z]/.test(key)) {
            // TODO 整理固定的 Event
            let func = attrs[key];
            if(Array.isArray(func)) {
                func = func.filter(f => typeof f === 'function');
                const reg = /^on(.*)/.exec(key);
                if(reg[1]) {
                    const eventName = lowerFirstLetter(reg[1]);
                    func.forEach(f => {
                        _jflowInstance.addEventListener(eventName, f);
                    });
                }
            } else if(func && typeof func === 'function') {
                const reg = /^on(.*)/.exec(key);
                if(reg[1]) {
                    _jflowInstance.addEventListener(lowerFirstLetter(reg[1]), func);
                }
            }
        }
    });
}

var JFlowComponent = {
    props: {
        configs: {
            type: Object,
            default: function () {
                return {};
            },
        },
        loading: Boolean,
        genVueComponentKey: {
            type: Function,
        }
    },
    inheritAttrs: false,
    setup(props, { slots, attrs, emit, expose }) {
        const { genVueComponentKey } = props;
        const genLinkVueComponentKey = (meta) => {
            const k1 = genVueComponentKey(meta.from.source);
            const k2 = genVueComponentKey(meta.to.source);
            const k3 = meta.part;
            return `${k1}-${k2}-${k3}`
        };

        const className = attrs.class;
        const style = attrs.style;
        const divEl = ref();
        let stopLoading = false;
        const renderNodes = ref([]);
        const renderLinks = ref([]);
        const _jflowInstance = new JFlowInstance__default(toRaw(props.configs));
        useStack(_jflowInstance);
        useLinkStack(_jflowInstance);
       

        const genNodeLinkMeta = () => {
            const nodes = _jflowInstance._layout.flowStack.map(meta => {
                const { type, layoutNode, source } = meta;
                const map = _jflowInstance.source_Layout_Render_NodeMap;
                let obj;
                const s = toRaw(source);
                const ly = toRaw(layoutNode);
                if(map.has(s)) {
                    obj = map.get(s);
                } else {
                    obj = map.set(s);
                }
                obj.layoutNode = ly;
                return meta;
            });
            const links = _jflowInstance._layout.flowLinkStack.slice();
            return [ nodes, links ];
        };

        const loadingNodes = (nodes, links) => {
            emit('update:loading', true);
            let i = 0;
            const tl = () => {
                if(stopLoading) {
                    return;
                }
                const end = i + 100;
                const linkPart = links.slice(i, end);
                if(linkPart.length) {
                    // this.renderLinks.splice(this.renderLinks.length,  0, ...linkPart);
                    renderLinks.value = renderLinks.value.concat(linkPart); // faster
                    i = end;
                    requestAnimationFrame(tl);
                } else {
                    requestAnimationFrame(mountJFlow.bind(this));
                }
            };
            const tn = () => {
                if(stopLoading) {
                    return;
                }
                const end = i + 100;
                const part = nodes.slice(i, end);
                if(part.length) {
                    // this.renderNodes.splice(this.renderNodes.length,  0, ...part);
                    renderNodes.value = renderNodes.value.concat(part);
                    i = end;
                    requestAnimationFrame(tn);
                } else {
                    i = 0;
                    requestAnimationFrame(tl);
                }
            };
            requestAnimationFrame(tn);
        };

        onBeforeMount(() => {
            loadingNodes(...genNodeLinkMeta());
        });



        const mountJFlow = () => {
            if(stopLoading) {
                return;
            }
            _jflowInstance.$mount(divEl.value);
            bindEvent(_jflowInstance, attrs);
            emit('update:loading', false);
        };

        onUnmounted(() => {
            if(_jflowInstance.destroy) {
                _jflowInstance.destroy(); 
            }
            stopLoading = true;
        });

        const syncNodeLink = (nodes, links) => {
            renderNodes.value = nodes.slice();
            renderLinks.value = links.slice();
        };

        // syncNodeLink(...genNodeLinkMeta());
        // nextTick(() => {
        //     mountJFlow();
        // })


        const reflow = (preCallback, afterCallback) => {
            syncNodeLink(...genNodeLinkMeta());
            nextTick(() => {
                if(preCallback) {
                    preCallback();
                }
                _jflowInstance.recalculate();
                _jflowInstance.scheduleRender(() => {
                    if(afterCallback) {
                        afterCallback();
                    }
                });

            });
        };

        const syncLayout = () => {
            syncNodeLink(...genNodeLinkMeta());
        };

        const getInstance = () => {
            return _jflowInstance;
        };


        const renderJFlow = (() => {
            let __renderInSchedule__ = false;
            return () => {
                if(__renderInSchedule__) {
                    return;
                }
                __renderInSchedule__= true;
                nextTick(() => {
                    _jflowInstance._render();
                    __renderInSchedule__ = false;
                });
            }
        })();

        provide('getJFlow', getInstance);
        provide('renderJFlow', renderJFlow);

        expose({
            reflow,
            renderJFlow,
            getInstance,
            syncLayout
        });


        return () => {
            return h('div', {
                class: className,
                style: style,
                ref: divEl 
            },
            !renderNodes.value.length ? null: h('div', [
                ...renderNodes.value.map(node => {
                    if(!node) {
                        return null
                    }
                    let { type, source, layoutNode } = node;
                    // layoutNode = toRaw(layoutNode);
                    if(!slots[type]) {
                        if(slots['jflowcommon']){
                            type = 'jflowcommon';
                        } else {
                            return null;
                        }
                    }
                    const [vnode] = slots[type]({ source, layoutNode });
                    vnode.key = genVueComponentKey(source);   
                    return vnode;
                }).filter(n => !!n),
                ...renderLinks.value.map(meta => {
                    let type = meta.type || 'plainlink';
                    if(!slots[type]) {
                        return null;
                    }
                    const [vnode] = slots[type]({ configs: meta });
                    vnode.key = genLinkVueComponentKey(meta);
                    return vnode
                })

            ]))
        };
    },
};

function diff( a, b ){
    return Object.keys(b).some(k => b[k] !== a[k]) || Object.keys(a).some(k => b[k] !== a[k]);
}
function JFlowInstance (nameNode) {
    const builder =  typeof nameNode === 'string'
        ? JFlowInstance$1[nameNode]
        : nameNode;
    return {
        inheritAttrs: false,
        props: {
            configs: {
                type: Object,
                default: function () {
                    return {};
                },
            },
            visible: {
                type: Boolean,
                default: true,
            },
            source: {
                type: Object,
            }
        },
        setup(props, { attrs, expose }) {
            const addToBelongStack = inject('addToStack');
            const removeFromBelongStack = inject('removeFromStack');
            const renderJFlow = inject('renderJFlow');
            const _jflowInstance =  new builder(toRaw(props.configs));
            bindEvent(_jflowInstance, attrs);
            addToBelongStack(_jflowInstance, toRaw(props.source));
            
            const stop0 = watch(() => props.configs, (val, oldVal) => {
                if(!diff(val, oldVal)){
                    return;
                }
                _jflowInstance.setConfig(val);
                renderJFlow();
            });
            const setVisible = (val) => {
                _jflowInstance.visible = val;
                renderJFlow();
            };
            const stop1 = watch(() => props.visible, setVisible);

            const stop2 = watch(() => props.source, (val) => {
                _jflowInstance._jflow.setRenderNodeBySource(toRaw(val), _jflowInstance);
            });
            setVisible(props.visible);
            onUnmounted(() => {
                stop0();
                stop1();
                stop2();
                _jflowInstance.destroy();
                removeFromBelongStack(_jflowInstance);
            });

            expose({
                _jflowInstance,
            });
            return () => null;
        }
    }
}

function JFlowLink (nameNode) {
    const builder =  typeof nameNode === 'string'
        ? JFlowInstance$1[nameNode]
        : nameNode;
    return {
        inheritAttrs: false,
        props: {
            configs: {
                type: Object,
                default: function () {
                    return {};
                },
            },
            from: Object,
            to: Object,
        },
        setup(props, { attrs, expose }) {
            const addToLinkStack = inject('addToLinkStack');
            const removeFromLinkStack = inject('removeFromLinkStack');
            const getJFlow = inject('getJFlow');
            const renderJFlow = inject('renderJFlow');
            const jflow = getJFlow();
            const exposeObj = {
                _jflowInstance: null,
            };
            const createInstance = (fromInstance, toInstance) => {
                if(fromInstance && toInstance) {
                    const _jflowInstance = new builder({
                        ...props.configs,
                        from: fromInstance,
                        to: toInstance,
                    });
                    bindEvent(_jflowInstance, attrs);
                    addToLinkStack(_jflowInstance, toRaw(props.from), toRaw(props.to));   
                    exposeObj._jflowInstance = _jflowInstance;
                }
            };
            

            const refresh = () => {
                const fromInstance = jflow.getRenderNodeBySource(toRaw(props.from));
                const toInstance = jflow.getRenderNodeBySource(toRaw(props.to));
                if(!exposeObj._jflowInstance) {
                    createInstance(fromInstance, toInstance);
                } else {
                    exposeObj._jflowInstance.setConfig({
                        ...props.configs,
                        from: fromInstance,
                        to: toInstance,
                    });
                }    
                renderJFlow();
            };

            refresh();
            const stop = watchEffect(() => {
                refresh();
            }, {
                flush: 'post',
            });
            onUnmounted(() => {
                stop();
                if(exposeObj._jflowInstance) {
                    exposeObj._jflowInstance.destroy();
                    removeFromLinkStack(exposeObj._jflowInstance, toRaw(props.from), toRaw(props.to));
                }
               
            });

            expose(exposeObj);
            return () => null;
        }
    }
}

function JFlowGroup (nameNode) {
    const builder =  typeof nameNode === 'string'
        ? JFlowInstance$1[nameNode]
        : nameNode;
    return {
        inheritAttrs: false,
        props: {
            configs: {
                type: Object,
                default: function () {
                    return {};
                },
            },
            visible: {
                type: Boolean,
                default: true,
            },
            source: {
                type: Object,
            }
        },
        setup(props, { slots, attrs, expose }) {
            const addToBelongStack = inject('addToStack');
            const removeFromBelongStack = inject('removeFromStack');
            const renderJFlow = inject('renderJFlow');
            const _jflowInstance =  new builder(toRaw(props.configs));
            useStack(_jflowInstance);
            bindEvent(_jflowInstance, attrs);
            addToBelongStack(_jflowInstance, toRaw(props.source));
            
            const setVisible = (val) => {
                _jflowInstance.visible = val;
                renderJFlow();
            };
            const stop0 = watch(() => props.configs, (val, oldVal) => {
                if(JSON.stringify(val) === JSON.stringify(oldVal)){
                    return;
                }
                _jflowInstance.setConfig(val);
                renderJFlow();
            });

            const stop1 = watch(() => props.visible, setVisible);

            const stop2 = watch(() => props.source, (val) => {
                _jflowInstance._jflow.setRenderNodeBySource(toRaw(val), _jflowInstance);
            });

            setVisible(props.visible);

            onMounted(() => {
                _jflowInstance.recalculate();
            });
            onUpdated(() => {
                _jflowInstance.recalculateUp();
            });
            onUnmounted(() => {
                stop0();
                stop1();
                stop2();
                _jflowInstance.destroy();
                removeFromBelongStack(_jflowInstance);
            });

            expose({
                _jflowInstance,
            });
            
            return () => h('jflow-group', slots.default())
        }
    }
}

var JFlowTextGroup = {
    props: {
        configs: {
            type: Object,
            default: function () {
                return {};
            },
        },
        visible: {
            type: Boolean,
            default: true,
        },
        source: {
            type: Object,
        },
        genVueComponentKey: {
            type: Function,
        }
    },
    inheritAttrs: false,
    setup(props, { slots, attrs, emit, expose }) {
        const { genVueComponentKey } = props;

        const addToBelongStack = inject('addToStack');
        const removeFromBelongStack = inject('removeFromStack');
        const renderJFlow = inject('renderJFlow');
        const renderNodes = ref([]);

        const _jflowInstance = new TextGroup(toRaw(props.configs));
        useStack(_jflowInstance);
        bindEvent(_jflowInstance, attrs);
        addToBelongStack(_jflowInstance, toRaw(props.source));

        const setVisible = (val) => {
            _jflowInstance.visible = val;
            renderJFlow();
        };
        
        const stop0 = watch(() => props.configs, (val, oldVal) => {
            if(JSON.stringify(val) === JSON.stringify(oldVal)){
                return;
            }
            _jflowInstance.setConfig(val);
            renderJFlow();
        });

        const stop1 = watch(() => props.visible, setVisible);

        const stop2 = watch(() => props.source, (val) => {
            _jflowInstance._jflow.setRenderNodeBySource(toRaw(val), _jflowInstance);
        });
        setVisible(props.visible);

        const genTextElementMeta = () => {
            renderNodes.value = _jflowInstance._flattenTxtElem.filter(elem => elem.type !== 'text');
        };
        genTextElementMeta();

        const reflow = () => {
            _jflowInstance.refreshTextElements();
            genTextElementMeta();
            nextTick(() => {
                _jflowInstance.refresh();
            });
        };

        onMounted(() => {
            _jflowInstance.recalculate();
        });
        onUpdated(() => {
            _jflowInstance.recalculateUp();
        });
        onUnmounted(() => {
            stop0();
            stop1();
            stop2();
            _jflowInstance.destroy();
            removeFromBelongStack(_jflowInstance);
        });

        expose({
            _jflowInstance,
            reflow,
        });
        
        return () => {
            if(renderNodes.value.length === 0) {
                return h('jflow-group');
            }
            return h('div', renderNodes.value.map(textElement => {
                let { type, source } = textElement;
                if(!slots[type]) {
                    if(slots['jflowcommon']){
                        type = 'jflowcommon';
                    } else {
                        return null;
                    }
                }
                const [vnode] = slots[type]({ source, textElement });
                vnode.key = genVueComponentKey(source);   
                return vnode;
            }).filter(n => !!n))
        }
    }
};

function JFlowLinkGroup (builder) {
    return {
        inheritAttrs: false,
        props: {
            configs: {
                type: Object,
                default: function () {
                    return {};
                },
            },
            visible: {
                type: Boolean,
                default: true,
            },
            source: {
                type: Object,
            },
            genVueComponentKey: {
                type: Function,
            }
        },
        setup(props, { attrs, slots, expose }) {
            const addToBelongStack = inject('addToStack');
            const removeFromBelongStack = inject('removeFromStack');
            const renderJFlow = inject('renderJFlow');
            const _jflowInstance =  new builder(props.configs);
            useStack(_jflowInstance);
            bindEvent(_jflowInstance, attrs);
            addToBelongStack(_jflowInstance, toRaw(props.source));
            const renderLinks = ref([]);
            const genLinks = () => {
                renderLinks.value = _jflowInstance._layout.flowLinkStack.slice();
            };
            genLinks();
            const setVisible = (val) => {
                _jflowInstance.visible = val;
                renderJFlow();
            };
            const stop0 = watch(() => props.configs, (val, oldVal) => {
                if(JSON.stringify(val) === JSON.stringify(oldVal)){
                    return;
                }
                _jflowInstance.setConfig(val);
                renderJFlow();
            });
            const stop1 = watch(() => props.visible, setVisible);

            const stop2 = watch(() => props.source, (val) => {
                _jflowInstance._jflow.setRenderNodeBySource(toRaw(val), _jflowInstance);
            });

            setVisible(props.visible);
            
            onMounted(() => {
                _jflowInstance.recalculate();
            });
            onUpdated(() => {
                _jflowInstance.recalculateUp();
            });
            onUnmounted(() => {
                stop0();
                stop1();
                stop2();
                _jflowInstance.destroy();
                removeFromBelongStack(_jflowInstance);
            });
            const getLinkName = (link) => {
                const type = link.type;
                if(!slots[type]) {
                    return 'plainlink'
                }
                return type;
            };
            const genLinkVueComponentKey = (meta) => {
                const k1 = props.genVueComponentKey(meta.from.source);
                const k2 = props.genVueComponentKey(meta.to.source);
                const k3 = meta.part;
                return `${k1}-${k2}-${k3}`
            };

            expose({
                genLinks,
                _jflowInstance,
            });

            return () => h('jflow-group', [
                ...slots.default(),
                ...renderLinks.value.map(meta => {
                    const type = getLinkName(meta);
                    if(!slots[type]) {
                        return null;
                    }
                    const vnode = slots[type]({ 
                        configs: meta 
                    });
                    vnode.key = genLinkVueComponentKey(meta);
                    return vnode;
                })
            ])
        }
    }
}

const JFLOW_NODES = [
    'Point',
    'Rectangle',
    'Capsule',
    'Diamond',
    'Rhombus',
    'Text',
    'Icon',
    'ShadowDom',
    'TextEditor',
];
const JFLOW_LINKS = [
    'Link',
    'PolyLink',
    'BezierLink'
];
const JFLOW_GROUPS = [
    'CapsuleGroup',
    'CapsuleVerticalGroup',
    'DiamondGroup',
    'DiamondVerticalGroup',
    'RhombusGroup',
    'PointGroup',
    'ScrollGroup',
];

const components = [
    {
        name: 'Jflow',
        component: JFlowComponent,
    },
    {
        name: 'Group',
        component: JFlowGroup('Group'),
    }, 
    ...JFLOW_GROUPS.map(name => ({
        name,
        component: JFlowGroup(name)
    })),
    ...JFLOW_NODES.map(name => ({
        name,
        component: JFlowInstance(name)
    })),
    ...JFLOW_LINKS.map(name => ({
        name,
        component: JFlowLink(name)
    })),
    {
        name: 'TextGroup',
        component: JFlowTextGroup
    }
];
const componentPrefix = 'j';
customElements.define('jflow-group', class extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({mode: 'open'});
    }
});
/**
 * @module JFlowVuePlugin 
 */
const JFlowVuePlugin = {
    /**
     * 安装 JFlowVuePlugin
     * @function
     * @param {Vue} Vue - Vue
     * @param {Object} options - Vue plugin 配置
     * @param {string} options.prefix - 组件前缀，默认是 j
     * @param {Object} options.custom - 自定义组件，形式为 { key: {@link:Instance} }
     */
    install: (Vue, options = {}) => {
        let prefixToUse = componentPrefix;
        if(options && options.prefix){
            prefixToUse = options.prefix;
        }        components.forEach(k => {
            Vue.component(`${prefixToUse}${k.name}`, k.component);
        });

        if(options.customInstance) {
            Object.keys(options.customInstance).forEach(name => {
                Vue.component(`${prefixToUse}${name}`, JFlowInstance(options.customInstance[name]));
            });
        }
        if(options.customGroups) {
            Object.keys(options.customGroups).forEach(name => {
                Vue.component(`${prefixToUse}${name}`, JFlowGroup(options.customGroups[name]));
            });
        }
        if(options.customLink) {
            Object.keys(options.customLink).forEach(name => {
                Vue.component(`${prefixToUse}${name}`, JFlowLink(options.customLink[name]));
            });
        }
    }
};

export { JFlowLinkGroup, JFlowVuePlugin };
//# sourceMappingURL=jflow-vue3-plugin.es.min.js.map
